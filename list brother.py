#chapter03-3
#파이썬리스트
#자료구조에서 중요
#list 자료형 ( 순서o 중복o 삭제o )

# 선언 list란? 서로 다른 형태를 한 묶음에 묶능거
a=[]
b=list()
c=[70,75,80,85]
print(len(c)) # 4가 나옴(70 75 80 85)
d=[1000,10000,'ACE','base','captine'] #list란 서로 다른 자료형을 한 묶음으로 묶는거
e=[1000,10000,['ACE','base','captine']]
f=[21.42,'foobar',3,4,False,3.141592]

#인덱싱 = 내가 원하는 데이터를 꺼내오는 과정
print('>>>>>')
print('d-',type(d),d)
print('d-',d[1]) #d=[1000,10000,'ACE','base','captine'] 여기서 첫번째에 짱박혀있는 1000만 꺼내온다는 뜻
print('d-',d[1]+d[1]+d[1]) #여기 안에서 연산도 됨 ㅋㅋ개꿀 print('d-',d[1]+d[1]+d[2]) 근데 이렇게 [2]로 숫자 바꾸는건 안되는듯;;?
print(d[-1]) #캡틴이 올거임 왜냐면 -1은 오른쪽에서 첫번째 라는 뜻
print(e[-1][1]) #♡ e=[1000,10000,['ACE','base','captine']] e는 안에 자료가 3개임 . [-1] 은 ['ACE','base','captine'] 이고 [1]은 이 안에서 첫번째를 나타내는 것이기 때문에 base가 나타남 ACE는0번째
print(list(e[-1][1])) # ['b', 'a', 's', 'e'] 이렇게 묶여진 답으로 나옴


#슬라이싱
print('>>>>>')
print('d-',d[0:3]) #d의 0부터 3까지 나와라
print('d-',d[2:]) #2번째부터 끝까지 나와라
print('e-',e[-1][1:3]) # e=[1000,10000,['ACE','base','captine']] -base','captine 이 답으로 나옴

#리스트연산
print('>>>>>')
print('c+d=',c+d)#c+d= [70, 75, 80, 85, 1000, 10000, 'ACE', 'base', 'captine'] list +list는 리스트 채로 더해짐>
print('c*3=',c*3) #c*3= [70, 75, 80, 85, 70, 75, 80, 85, 70, 75, 80, 85] 70,75,80,85*3 개 한 값이 나옴
'''print("'test'+c[0]=",'Test'+c[0])''' #c[0]이 70 이라 숫자라서 'Test' 와 더했을때 오류뜸 , c[0]을 str문자형으로 바꿔주자
print("'test'+c[0]=",'Test'+str(c[0])) #'test'+c[0]= Test70 문자끼리 합친 값이 나옴

'''a=[]
b=list()
c=[70,75,80,85]
print(len(c)) # 4가 나옴(70 75 80 85)
d=[1000,10000,'ACE','base','captine'] #list란 서로 다른 자료형을 한 묶음으로 묶는거
e=[1000,10000,['ACE','base','captine']]
f=[21.42,'foobar',3,4,False,3.141592]'''

#값 비교
print(c==c[:3]+c[3:])
#어케아냐?
print(c)
print(c[:3])
print(c[3:]) #위에꺼까지 더하면 딱 print(c)나옴 ㅋㅋ맞음

#identity(id)

temp=c  #temp 이 개념이 헷갈리시는 분들은 콜라가 들어있는 컵(previous)과 사이다가 들어있는 컵(current)이 있는데 둘의 내용물을 바꾼다고 생각해보시면 이해가 될 것입니다. 온전히 컵만 바뀐 채로 내용물이 유지되려면, 어떤 빈 컵(temp)이 있어야되고 이 곳에 콜라든 사이다든 임시로 담아두었다가 바꿔야된다는걸 직관적으로 깨닫게 되실겁니다.
print(temp,c)
print(id(temp))
print(id(c))

#리스트 수정, 삭제
print('>>>>')
c[0]=4 #c=[70,75,80,85] c[0]은 원래 70인데 4로 수정함
print('c-',c) #[4, 75, 80, 85] 로 바뀜
c[1:2]=['a','b','c']#[a,b,c]
print(c[1:2]) 
c[1]=['a','b','c']
c[1:3]=[]
print(c)
#삭제
del c[2] # c의 2번째를 지워줘 라는 뜻

#리스트 함수(append() sort() reverse() insert() remove() del() pop())
a=[5,2,3,1,4]
print(a)
#이 뒤에다 함수 10을 (a=[5,2,3,1,4.10] 으로 만들고싶다)추가하고시퍼요
# a[5]=10(x)
a.append(10) #append() 는 마지막 끝부분에 ()안에 숫자를 추가해주는 거임
a.sort() #sort() 함수는 오름차순으로 정렬해주는거 이런 함수를 적용시킬땐 앞에 a.sort 처럼 앞글자 . 을 선언하고 출력해야댐
print(a) #[1, 2, 3, 4, 5, 10] 이렇게 정렬됨
a.reverse()
print(a)#[10, 5, 4, 3, 2, 1] 지금까지 출력된 함수를 거꾸로 출력해주는거
print(a.index(3))# a함수에서 3번째 숫자를 가져와 라는 뜻 근데 걍 print(a[3])이랑 똑같음
print(a[3])
#만약 나는 [10, 5, 4, 3, 2, 1] 여기에서 5와 4 사이에 값을 넣고 싶어.. 이런 개노답 상태가 생겻다면..?
#답은 insert!!
a.insert(2,7)#=> 나는 a리스트함수에서 2번째 짜리에 7을 넣을거야 2번째 자리 숫자인 4가 밀려나고 그자리에 7이옴 ㅋㅋ 
print(a)
a.reverse()
print(a)
#삭제
del a[3] # [1, 2, 3, 4, 7, 5, 10] 여기서 3번을 지우세요 라는 뜻 근데 잘 안씀 ㅋㅋ몇번째 숫자인지 찾는거 개고생이라 대신 remove씀
#remove 이건 걍 내가 지우고싶은 숫자를 쓰면됨
a.remove(10) 
print(a)
#pop
print(a.pop()) # pop 은 제일 끝에 있던 원소를 꺼내서 출력해오고 나머지 원소들로 리스트를 다시 구성해서 나오는거임. 그래서 2문장이 출력됨
print(a)
'''5 pop!
[1, 2, 3, 7]''' #이렇게 나옴
#pop다시..
b=[1,2,3,4]
print(b.pop())
print(b)
'''4
[1, 2, 3]'''
b.pop()
print(b)
print(a.count(4)) #[] 리스트 안에서 내가 찾는 값이 몇개가 있는지 찾을 때 쓰는거임
print(b.count(1)) # [1,2] 에 1이 한개있으니까 1이라고 답이 출력됨
## 연장하기 extend
b=[1,2]
ex=[8,9] #8,9를 b리스트에서 연장시킨다는 뜻
b.extend(ex) 
print(b)

#삭제 : remove, pop , del 

#반복문 활용 (이건 나중에 배울거임 신경 ㄴㄴ)
while b:
    data=b.pop()
    print(data)

